This is a flag algebra program package developed by Leonardo Nagami Coregliano (lenacore@gmail.com) used to
obtain the results of the paper "On the maximum density of fixed strongly connected subtournaments",
coauthored with Roberto Freitas Parente and Cristiane Maria Sato, and can be used for the following purposes.

1 (CHK) - Check the correctness of the results in the paper above.

2 (SOL) - Obtain other semidefinite solutions to the problems in the paper above.

3 (OTH) - Obtain bounds using the flag algebra semidefinite method for other extremal combinatorics problems
(even in theories other than that of tournaments).

Each of the uses above are described in the sections of this README.txt file (simply search for the three
capital letters in parentheses to skip to the desired section).

Instructions for compilation are described in Section 0 (CMP) and the executable file structure is described
in Section 00 (STR).

Before starting, please see LICENSE.txt.

==============================================================================================================

Section 0 (CMP) Instructions for compilation

==============================================================================================================

To compile and run this program package, you will need the following.

1 - G++ compiler (from GCC) [other C++ compilers should also work];
2 - LAPACK and LAPACKE libraries;
3 - CSDP (or SDPA);
4 - GFortran (typically included in GCC);
5 - Makefile

In a UNIX based system, simply run make in the main folder to compile the program package (some of the
parameters, such as OPTFLAGS, CXX, etc., can be changed, check makefile for more documentation).

In another system, you will need a program to emulate the syntax of GNU makefile and of mkdir (an example for
a Windows system can be seen in "makeWin.bat", in which "gnumake" emulates makefile and "gnumkdir" emulates
mkdir).

==============================================================================================================

Section 00 (STR) Executable file structure

==============================================================================================================

This program package is organized into modules, one for each universal theory. This package in particular
provides the modules "Graph", "Digraph" and "Tournament". The executables for each module will be placed under
a folder with the modules name in bin/executables/ upon compilation.

Here is a list of the executables generated for the "Tournament" module and their purpose.

- EnumerateFlagTournament
-- Enumerates all tournaments of a given size.
- ExpandFlagTournament
-- Computes the flag algebra expansion of a given flag to a given size.
- ExpandProductFlagTournament
-- Computes the flag algebra expansion of a product of two flags to a given size.
- SDPcheckerTournament
-- Checks if a semidefinite method solution is valid (see Section 1).
- SDPgenTournament
-- Generates an SDP problem coming from a flag algebra semidefinite method (see Section 2).
- SDProunderTournament 
-- Attempts to round an SDP solution (see Section 2).
- SDPsolverTournament
-- Generates SDP programs and runs solver until a conjectured value is obtained as a bound (see Section 2).
- TestFlagTournament
-- Tests various flag algebra operations of tournaments (see Section 3).

Each module has analogous of these programs with similar names.

For more options of the usages, most of the above support the option --help.

For more documentation, go to the specific .cpp source file in src/include/Flag/ (note that this is NOT in the
module folder, but in the Flag folder).

All other executables are meant only for testing.

==============================================================================================================

Section 1 (CHK) - Checking correctness of the results of the paper

==============================================================================================================

Within the folder "results", you will find the solution files generated by this program package specifically
for the aforementioned paper.

Each filename starts with the name of the tournament being maximized and can be either in matrix format or
squares format (see SOLUTION_FORMAT.txt). Not all solutions have a rounded squares format since the
eigenvector entries are not necessarily rational.

We also provide more human readable files with the matrices of each problem (which are the same as the ones in
the aforementioned paper).

For example, for the tournament T7, we have the files:
- T7_matrices.txt: matrices in human readable format.
- T7_rounded.txt: solution in matrix format.
- T7_rounded_squares.txt: solution in squares format.

To check the correctness of the results, run SDPcheckerTournament (in the folder of the solution files) and
follow the instructions of the program using either the matrix format or the squares format.

==============================================================================================================

Section 2 (SOL) - Obtaining other semidefinite solutions to the problems

==============================================================================================================

There are two ways of trying to obtain flag algebra bounds using this program: one more manual and fine tuned
(using SDPgen) and one more automatic (using SDPsolver).

Simply run the desired program and follow the instructions (the documentation of format of tournament I/O can
be found in src/lib/Tournament/FlagTournament.cpp). [Obs.: the number of forbidden objects is 0 for the
problems in the paper (see Section 3)]

If you choose SDPgen, you will either have to manually run the CSDP in the file produced, or run SDPgen with
option -s0 (for CSDP; or -s1 for SDPA). In the latter case, a solution file will also be produced in the
format accepted by SDProunder (see below).

If you choose SDPsolver, solution files will be produced automatically.

After you run one of SDPgen + CSDP or SDPsolver, you may want to round the obtained solution using
SDProunder. It requires a solution either in matrix format or squares format (see SOLUTION_FORMAT.txt) that
can be automatically produced by these programs. However, if the solution is too large, SDProunder may not be
able to round the solution (either because of hardness of calculations or insufficient memory, the latter is
indicated by the program terminating under the exception std::bad_alloc). SDPsolver has functionalities
offered right after a solution is found to try to reduce the size of the solution automatically. Note also
that SDProunder tries to find a way to round the solution to a rational one; so if the exact solution had
irrational entries (this can happen even if the problem was rational), SDProunder is bound to fail.

To round the problems, SDProunder asks for several parameters. There is very little intuition as to what are
proper values for these, nevertheless here are some brief explanation as to their meaning and some tipical
values used for our application.
- epsilon 1: precision of positive semidefinite restrictions.
-- the program will force any eigenvalue less than epsilon 1 to be 0 in its attempt to round the program.
-- typical value range: 1e-2 to 1e-6.
- epsilon 2: precision for conjectured value rounding.
-- the program will force the objective values that are less than epsilon 2 far away from the conjectured
value to be the conjectured value.
-- typical value range: 1e-2 to 1e-6
- epsilon 3: precision for matrix value rounding
-- the program will round free variables to the solution values up to epsilon 3 precision
-- typical value range: 1e-2 to 1e-6
- nRoundEigen: maximum denominator for eigenvector rounding.
-- the program will attempt to round eigenvector entries using denominators up to the factorial of
nRoundEigen.
-- typical value range: 10 to 20.

If SDProunder fails to round the problem, it will provide suggestions on how to change these parameters for a
better attempt at rounding. Be advised that the smaller the value of epsilon 3 and the larger the value of
nRoundEigen, the greater will be the memory usage of the program.

The typical process of trying to find a bound using this program package is the following:
1 - Run SDPsolver until it finds a solution.
2 - Run SDProunder on the solution, first without using the solution reduction functionalities of SDPsolver.
3 - If SDProunder has too much trouble, reduce the solution size automatically with SDPsolver and try
SDProunder again.
4 - If SDProunder still has too much trouble, try to manually tweak the solution using SDPgen (small solutions
are not necessarily easier to round, just tipically easier).
5 - Once SDProunder successfully rounds the solution, check its correctness using SDPchecker.

It should be noted that even running the same problems as the ones in the paper on these programs will most
likely not yield the same solution matrices as in the paper since these depend both on CSDP (or whatever
semidefinite solver is being used) and sometimes also in fine tuning using SDPgen.


==============================================================================================================

Section 3 (OTH) - Obtaining other bounds using the flag algebra semidefinite method

==============================================================================================================

The procedure described in Section 2 works for any module within this package, that is, for any of the
theories of graphs, digraphs or tournaments. It also works for any theory obtained from these by forbidding a
finite number of submodels (simply type the number of forbidden submodels and each of them when prompted by
the programs).

Furthermore, this program package can be extended with other modules for other universal theories.

As an example, if you want to add a module, say Perm, for the theory of permutations, you need to do the
following.
1 - Create the folders src/include/Perm/ and src/lib/Perm/
2 - Create the files src/include/Perm/FlagPerm.h and src/lib/Perm/FlagPerm.cpp
3 - In the file FlagPerm.h, implement an interface for a class Perm modeled in the class UniversalTheoryObject,
described and documented in src/include/Flag/Flag.h.
4 - Implement the class Perm in src/lib/Perm/FlagPerm.cpp.
5 - Add Perm to the variable FLAGMODULES in Makefile.

We recommend to use the module Graph as a base model to understand how things should be implemented.
